4.6
4.6.1
	그림 4.17의 경우 i형식 명령어의 연산에 사용하는 15-0비트를 ALU유닛에서 offset과 덧셈연산 후 메모리 주소의 연산에 사용하고있습니다.
	i형식 명령어인 addi와 같은 명령어는 RegDst:0, Branch:0, MemRead:X, MemtoReg:0, ALUOp:00, MemWrite:X, ALUSrc:1, RegWrite:1로 설정하면 잘 작동한다.
	하지만, 논리연산의 경우 부호를 유지하기 위해 최상위 비트값을 확장하는 sign-sxtension을 할 경우 andi와 같은 논리연산이 불가능하다.
	따라서 i형식 명령어의 논리연산의 경우 zero-extension유닛의 추가가 필요하다.
	Insrtuction16비트를 사용하는 것은 동일하기에, Sign-extend유닛의 직전 라인에서 분기해 Zero-extension유닛을 추가한다.
	따라서 부호확장과 0확장을 모두 진행한 뒤, Mux유닛을 두 확장유닛 뒤에 배치한 뒤, Control유닛에서 ItypeLogic(임시 이름)과 같은 제어신호를 보내게 해,
	연산의 종류에 따라 부호확장과 0확장값을 취사선택해 ALUSrc신호와 이어진 Mux유닛에 이어주면 i형식 논리연산도 수행 가능하다.
	즉, 논리연산을 위한 Zero-extend유닛, Mux유닛, 새로운 제어 신호가 추가로 필요하다.

4.6.2
	1번 문제의 해석에 기입한 대로 RegDst:0, Branch:0, MemRead:X, MemtoReg:0, ALUOp:add, MemWrite:X, ALUSrc:1, RegWrite:1신호를 생성한다.
	MemRead:X와 MemWrite가 Don't care인 이유는 MemtoReg값을 0으로 설정해 두어, Data memory유닛에서 어떠한 연산을 해도 그 값이 이용되는 일이 없기 때문이다.

4.16
4.16.1
	파이프라인 프로세서의 경우 클럭 사이클 시간은 가장 긴 시간을 갖는 데이터패스 지연시간과 같기 때문에 ID단계의 지연시간인 350ps이다.
	파이프라인되지 않은 프로세서의 경우 IF+ID+EX+MEM+WB지연시간을 모두 더한 값과 같기 때문에 250+350+150+300+200 = 1250ps이다.

4.16.2
	파이프라인 프로세서의 경우 각 데이터패스의 단계별 지연시간은 가장 지연시간이 큰 것으로 통일된다.
	따라서 가장 많은 시간을 소모하는 ID단계의 350ps * 5 = 1750ps를 갖는다.
	파이프라인되지 않은 프로세서의 경우 각 데이터패스의 지연시간을 모두 더한 값인 250+350+150+300+200 = 1250ps를 전체 지연시간으로 갖는다.

4.16.3
	가장 지연시간이 큰 ID단계를 둘로 나눈다면, ID1과 ID2로 나누어 각각 175ps로 분할될 것이다.
	가장 지연시간이 컸던 ID단계가 사라졌기 때문에 그 다음으로 지연시간이 컸던 MEM의 300ps를 사이클 시간으로 갖게된다.

4.16.4
	데이터 메모리는 Sign-extend한 Instruction값을 기반으로 메모리 주소를 계산해 값을 저장하거나 로드하는 유닛이다.
	따라서 Load와 Store명령어만이 데이터 메모리 유닛을 사용하며, 다른 명령어들은 메모리에 접근하지 않는다.
	따라서 Load와 Store명령어의 비율을 더하면, 20% + 15 = 35%이다.

4.16.5
	65% Write register포트는 RegWrite신호가 1인 경우에 사용된다.
	RegWrite신호가 1인 경우는, 메모리에서 레지스터 값을 불러오거나(Load), 값이나 논리연산을 한 뒤 레지스터에 저장하는 경우(ALU/Logic)이다.
	두 명령어의 비율을 더하면, 20% + 45% = 65%이다.

4.22
4.22.1
	sw	IF	ID	EX	MEM	WB
	lw		IF	ID	EX	MEM	WB
	sub			IF	ID	EX	MEM	WB
	beq				충돌(MEM연산중으로, IF 불가능) 

4.22.2
	명령어가 메모리에 있기 때문에, 명령어를 읽는 과정에서 메모리 참조가 일어난다.
	여기에 lw나 sw명령어에 의해 메모리에 접근중인(MEM) 경우엔 다른 명령어의 IF단계의 수행이 불가능해 문제가 생긴다.
	따라서, MEM과정을 수행하는 명령어의 위치를 바꾸더라도, 다른 명령어와의 충돌이 일어난다.

4.22.4
	명령어와 데이터가 동일한 메모리와 파이프라인을 사용하기 때문에 코드 추가를 이용한 방법은 메모리 자원의 사용처를 늘릴 뿐이다.
	따라서 NOP와 같은 방법으로는 구조적 해저드 해결이 불가능하다.

4.28
4.28.1
	분기 명령어 실행 빈도 = 25%, 전체 명령어의 cpi = 1로 본다.
	분기 예측 실패시 분기 명령어의 ID, EX단계에서 불러온 명령어 둘과, 새 명령어를 불러올 1사이클로 총 3사이클의 손실을 본다.
	예측의 실패율은 1 - 0.45 = 55%로 볼 수 있으며, 예측 성공시엔 cpi손실이 없을 것이다.
	따라서, 예측이 실패한 경우는 0.25*0.55*3 = 0.4125의 cpi가 추가될 것이다.
	
4.28.2
	분기예측 실패율은 45%며, 실패시 사이클 손실은 3으로 동일하다.
	4.28.1의 계산을 이용해 0.25*0.45*3 = 0.3375의 cpi가 추가된다.

4.28.3
	분기예측 실패율을 1-0.85 = 15%로 잡고 계산하면, 0.25*0.15*3 = 0.1125로 0.1125의 cpi가 추가될 것이다.

4.29
4.29.1
	분기 패턴은 분기, 비분기, 분기, 분기, 비분기이다.
	항상 분기한다고 예측하는 경우엔 5번의 예측에서 3회를 예측 성공해 60%의 정확도를 보일 것이다.
	항상 분기하지 않는다고 예측하는 경우엔, 5번의 예측에서 2회의 예측에 성공해 40%의 정확도를 보일 것이다.

4.29.2
	네 분기에 대한 예측이며, 초기 예측값은 NT이기 때문에
	분기: T		|	NT	|	T	|	T	|
	예측: NT	|	NT	|	NT	|	NT	|
	결과: X		|	O	|	X	|	X	|
	다음과 같은 과정을 거친 후에 예측기는 T로 예측을 바꾼다.
	하지만, 초기 4개의 분기에 대한 예측이기 때문에 예측기의 변동은 의미가 없는 상태로 25%의 정확도를 보여준다.

4.29.3
	10회의 진행, 즉 패턴을 두 번 반복한 뒤엔, 예측기의 예측이 T로 고정된다.
	분기: T		|	NT	|	T	|	T	|	NT	|	T	|	NT	|	T	|	T	|	NT	|
	예측: NT	|	NT	|	NT	|	NT	|	T	|	NT	|	T	|	NT	|	T	|	T	|
	결과: X		|	O	|	X	|	X	|	X	|	X	|	X	|	X	|	O	|	X	|
	따라서 10번까지의 예측률인 20%가 시행수가 많아질수록 5개의 패턴중 T의 비율인 60%에 가깝게 변할 것이다.